#include <iostream>
#include <stack>
#include <vector>
#include <queue>
#include <sstream>

using namespace std;

/**
 * Для транспортирования материалов из цеха А в цех В используется конвейер.
 * Материалы упаковываются в одинаковые контейнеры и размещаются на ленте
 * один за одним в порядке изготовления в цехе А.
 * Каждый контейнер имеет степень срочности обработки в цехе В.
 * Для упорядочивания контейнеров по степени срочности используют накопитель,
 * который находится в конце конвейера перед входом в цех В.
 *
 * Накопитель работает пошагово, на каждом шаге возможны следующие действия:
 * накопитель перемещает первый контейнер из ленты в цех В;
 * накопитель перемещает первый контейнер из ленты в склад (в складе каждый следующий контейнер помещается на предыдущий);
 * накопитель перемещает верхний контейнер из склада в цех В.
 *
 * Напишите программу, которая по последовательности контейнеров определит, можно ли упорядочить их по степени срочности пользуясь описанным накопителем.
 * 
 * Формат ввода:
 * Входной файл в первой строке содержит количество тестов N. Далее следует N строк,
 * каждый из которых описывает отдельный тест и содержит целое число K (1 ≤ K ≤ 10000) — количество
 * контейнеров в последовательности и K действительных чисел —
 * степеней срочности контейнеров в порядке их поступления из цеха А (меньшим числам соответствует большая степень срочности).
 * 
 * Формат вывода:
 * Каждая строка выходного файла должна содержать ответ для одного теста.
 * Необходимо вывести 1, если необходимое упорядочивание возможно, или 0 в противном случае.
 */

typedef vector<queue<double>> f_tests;

typedef vector<int> f_answers;

f_answers analyze(f_tests &tests, size_t N) {
    f_answers answers(N);

    for (int i = 0; i < N; i++) {
        stack<double> save;
        int a_i = 1;
        double last = -1e18, cur = 0.0;
        tests[i].pop(); // сначала лежит число коробок

        while (!tests[i].empty() || !save.empty()) {
            if (save.empty() && !tests[i].empty()) {
                cur = tests[i].front();
                save.push(cur);
                tests[i].pop();
                continue;
            }

            double save_top = save.top();
            if (!tests[i].empty()) {
                cur = tests[i].front();
                if (cur <= save_top) {
                    // убираем на склад убывающиеся последовательности
                    save.push(cur);
                    tests[i].pop();
                } else {
                    // когда приходит число большее, чем на вершине стеке, мы сначала извлекаем со стека
                    // так происходит до тех пор, пока не придёт число меньшее, чем на вершине, которое
                    // мы положим обратно на стек.
                    if (save_top < last) {
                        a_i = 0;
                    }
                    last = save_top;
                    save.pop();
                }
            } else {
                if (save_top < last) {
                    a_i = 0;
                }
                last = save_top;
                save.pop();
            }
        }
        answers[i] = a_i;
    }
    return answers;
}


int main(void) {
    string line;
    double tmp = 0;
    int N = 0;

    if (scanf("%d\n", &N) != 1) {
        return 1;
    }
    f_tests test(N);

    for (int i = 0; i < N; i++) {
        getline(cin, line);

        stringstream ss(line);
        while (ss >> tmp) {
            test[i].push(tmp);
        }
        line.clear();
    }

    f_answers answers = analyze(test, N);
    for (int j = 0; j < N; j++) {
        cout << answers[j] << endl;
    }

    return 0;
}