#include <iostream>
#include <vector>

/**
 * @brief
 * Дана текстовая строка. С ней можно выполнять следующие операции:
 * Заменить один символ строки на другой символ.
 * Удалить один произвольный символ.
 * Вставить произвольный символ в произвольное место строки.
 * Например, при помощи первой операции из строки «СОК» можно получить строку «СУК»,
 * при помощи второй операции — строку «ОК»,
 * при помощи третьей операции — строку «СТОК».
 * Минимальное количество таких операций,
 * при помощи которых можно из одной строки получить другую,
 * называется стоимостью редактирования или расстоянием Левенштейна.
 * Определите расстояние Левенштейна для двух данных строк.
 * Формат ввода:
 * Программа получает на вход две строки, длина каждой из которых не превосходит 1000 символов,
 * строки состоят только из заглавных латинских букв.
 * Формат вывода:
 * Требуется вывести одно число — расстояние Левенштейна для данных строк.
 */

using namespace std;

int dp2(const string &s1, const string &s2) {
    // +1, чтобы учесть тот случай, когда одна из строк пуста
    int n = s1.size() + 1, i = 0;
    int m = s2.size() + 1, j = 0;
    int tmp = 0;

    /**
     * ячейка с координатами (i,j) определяет минимальное
     * количество операций для преобразования i-элементов из первой строки
     * в j-элементов из второй строки.
     */
    vector<vector<int>> dp(n, vector<int>(m, 0));

    for (i = 0; i < n; i++) {
        dp[i][0] = tmp++;
    }
    tmp = 0;
    for (j = 0; j < m; j++) {
        dp[0][j] = tmp++;
    }

    for (i = 1; i < n; i++) {
        char s1_tmp = s1[i-1];
        char s2_tmp;
        for (j = 1; j < m; j++) {
            s2_tmp = s2[j-1];
            if (s1_tmp == s2_tmp) {
                dp[i][j] = dp[i-1][j-1];
            } else {
                /**
                 * Так как операция удаления выполняется через подъём на строку (i-1), то
                 * мы говорим, что удаляем символ из s1.
                 * Если же выполняем операцию добавления, то мы опускаемся на столбец ниже (j-1) - 
                 * то есть добавляем символ из s2.
                 * Тогда операция замены может быть представлена последовательностью (i-1) и (j-1),
                 * которая предполагает, что мы заменяем s1_tmp на s2_tmp
                 */
                dp[i][j] = 1 + min(dp[i-1][j-1], min(dp[i-1][j], dp[i][j-1]));
            }
        }
    }
    return dp[i-1][j-1];
}

int main(void) {
    string s1, s2;
    cin >> s1 >> s2;

    cout << dp2(s1, s2) << endl;

    return 0;
}
