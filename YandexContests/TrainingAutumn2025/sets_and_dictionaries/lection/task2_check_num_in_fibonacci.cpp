#include <iostream>
#include <stdint.h>
#include <vector>
#include <math.h>
#include <set>

/**
 * @brief
 * проверить, является ли длинное число
 * (до 5 тыс. цифр) числом Фибоначчи
 */

using namespace std;

/**
 * Числа Фибоначчи растут примерно также, как и функция
 * 2^n. Тогда мы можем попробовать подобрать число, до которого мы
 * будем считать числа Фибоначчи, которое точно покроет введённое.
 * 
 * 10^5000 < 2^20000 ( 10^5000 < 16^19997 ), где 10^5000 - это максимальное число из чисел из 5000 цифр. 
 * но числа Фибонначи растут медленнее, причём заметно медленнее, поэтому
 * нам понадобится досчитать до 40'000 числа Фибоначчи.
 * 
 * (Вообще числа Фибоначчи растут примерно по 2^fi, где fi=1.618, поэтому
 * fi^n ~= 2^20'000 => log(fi^n) =log(2^20'000) => n*log(fi) = 20'000*log(2) =>
 * => n = 20'000 * log(2)/log(fi) = 20'000 * 1.44 = 28'800 уже хватит),
 * то есть fi^28'800 даст примерно (~=) тоже число, что и 2^20'000)
 * 
 * Рассмотрим худший случай - каждая из 40'000 чисел Фибоначчи имеет
 * по 5'000 цифр, это 200 млн. цифр всего - это очень сложная арифметика. 
 * 
 * Поэтому нужно воспользоваться арифметикой остатков. 
 * Пусть есть некоторое число P и пусть есть несколько чисел Фибоначчи:
 * (F(i) + F(i+1) + F(i+2))%P = ((F(i) + F(i+1))%P + F(i+2))%P
 * 
 * Поэтому давайте хранить не сами числа Фибоначчи, а остатки по модулю на P,
 * которые дают числа Фибоначчи. Когда к нам придёт большое число, мы
 * посчитаем остаток от деления на P и проверим есть ли такой остаток
 * среди множества остатков от деления на P для чисел Фибоначчи.
 * 
 * Но как быть с коллизиями ?
 * Есть набор чисел: 1 1 2 3 5 8 13 21 34
 * посчитаем уникальные остатки от деления при условии, что P=10: 1 2 3 5 8 4
 * Пусть на вход подаётся число: 23, проверяем через остаток: 23%10=3, 3 есть
 * в множестве уникальных остатков ? да - получается, что это число Фибоначчи ?
 * Нет !
 * Поэтому давайте сделаем этот P достаточно большим, в районе миллиадров (10^9),
 * тогда вероятность коллизии достаточно небольшая - из миллиарда чисел помечено 40 тыс
 * (то есть мы берём последние 9-ть цифр от числа с 5000 элементами), но она
 * всё-таки есть.
 * Поэтому, чтобы избавиться от этой проблемы, мы посчитаем несколько разных
 * остатков (P1, P2, P3) и посмотрим, есть ли остаток от деления на каждый
 * из Pi. Если хотя бы нет в одном, то мы говорим, что это число не является
 * числом Фибоначчи, а в противном случае - является. Таким образом, мы
 * ещё больше уменьшим вероятность коллизии.
 */

int main() {
    int N, remainder_N, i = 0;
    int f1, f2;
    int needed_pow = pow(10,9);
    const int max_fib_idx = 40'000;

    vector<int> mods = {needed_pow+3, needed_pow+7, needed_pow+11};
    vector<multiset<int>> s(mods.size(), { 0 });
    bool is_fib_num = true;

    for (; i < mods.size(); i++) {
        f1 = 1, f2 = 1;
        s[i].insert(1);
        for (int j = 0; j < max_fib_idx; j++) {
            int tmp_f1 = f1;
            f1 = f2;
            f2 = (tmp_f1 + f2) % mods[i];
            s[i].insert(f2);
        }
    }

    cin >> N;

    for (i = 0; i < s.size() && is_fib_num; i++) {
        remainder_N = N % mods[i];
        
        if (s[i].find(N) == s[i].end()) {
            is_fib_num &= false;
        }
    }

    if (is_fib_num) {
        cout << "Yes" << endl;
    } else {
        cout << "No" << endl;
    }

    return 0;
}